# 컬렉션

컬렉션이란, 하나의 특정한 값이 아닌 여러개의 값을 포함하는 데이터 타입이다.

가장 많이 활용되는 세가지 컬렉션은 다음과 같다.

- 벡터
- 문자열
- 해시 맵

## 벡터

벡터는 단일 데이터 구조에 하나 이상의 값을 메모리 바로 옆에 붙이면서 저장하는 타입이다.

벡터 생성은 두 가지 방법이 있는데

1. Vec의 `new` 연관함수 사용
2. `vec!` 매크로 사용

```rust
let v: Vec<i32> = Vec::new()
let v = vec![1,2,3];
```

백터로부터 값을 읽는게 조금 복잡한데

```rust
let v = vec![1, 2, 3, 4, 5];

// 1. &와 []로 읽는 방법
let third: &i32 = &v[2];

// 2. get 메서드를 이용해 읽는 방법, 이때 Option<T> 타입을 리턴한다.
match v.get(2) {
    Some(third) => println(third),
    None => println!("None")
}
```

왜 러스트에서는 이 2가지 방법을 제공할까? <br>
그 이유는 1번의 방법으로 존재하지 않는 인덱스에 접근하려고 하면 프로그램이 panic 되지만<br>
2번의 방법은 Option의 None을 return하기에, panic 없이 동작하기 때문이다.

또한 벡터에 저장된 값에 모두 하나씩 접근하려면, iterate하는 것이 좋다.

```rust
let mut v = vec![1, 2, 3, 4, 5];
for i in &mut v {
    *i += 50;
}
```

## 문자열

러스트에서 문자열 타입은 String과 str가 있다.<br>
둘다 표준 라이브러리이며 모두 UTF-8 형식으로 인코딩 되어 있음<br>
하지만 String은 추가적으로 변경, 추가, 소유가 가능한 타입이 가능하다고 보면 된다.

문자열 생성은 이미 다뤘었다. <br>
사실 기본적인 오퍼레이션은 `Vec`와 같다고 보면 된다.

```rust
let mut s = String::new();
let s = String::from("문자열");
```

문자열 합치기는 `+`나 `format!`을 사용하면 됨

하지만 index로 문자열을 자르거나 조회하는 것은 불가능하다.<br>
그 이유는 String은 UTF-8로 인코딩하는데, 각 문자마다 1바이트를 사용하면 문제가 없지만<br>
특정 문자 같은 경우에는 1바이트보다 더 많은 바이트를 사용할 때가 있고,<br>
그 경우 index 위치의 값이 문자를 대변하지 않을 수도 있기에, 부정확한 결과를 리턴할 수 있기 때문이다.

그래서 표준 라이브러리에서 제공하는 메서드를 잘 찾아보고 사용하자.

문자열은 생각보다 복잡하다.<br>
바이트에 대한 개념도 잘 알아야 하고, 러스트에서 많은 제한을 두었기에<br>
개발자는 이에 대한 많은 헨들링을 구현해야 한다.

## 해시 맵

JavaScript의 객체 역할을 하는 친구이다.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("블루"), 10);
socres.insert(String::from("그린"), 50);
```

---
